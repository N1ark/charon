# Final LLBC before serialization:

// Full name: test_crate::SomeTrait
trait SomeTrait<Self>
{
    fn some_method<'_0> = test_crate::SomeTrait::some_method<'_0_0, Self>[Self]
}

// Full name: core::marker::Sized
#[lang_item("sized")]
pub trait Sized<Self>

// Full name: test_crate::Point
struct Point<T>
where
    [@TraitClause0]: Sized<T>,
{
  x: i32,
  y: u64,
  z: T,
}

struct test_crate::Point::<i32> {
  x: i32,
  y: u64,
  z: i32,
}

// Full name: test_crate::{impl SomeTrait for Point<i32>[Sized<i32>]}::some_method
fn {impl SomeTrait for Point<i32>[Sized<i32>]}::some_method<'_0>(@1: &'_0 (test_crate::Point::<i32>))
{
    let @0: (); // return
    let self@1: &'_ (test_crate::Point::<i32>); // arg #1
    let @2: (); // anonymous local
    let @3: bool; // anonymous local
    let @4: i32; // anonymous local
    let @5: bool; // anonymous local
    let @6: u64; // anonymous local
    let @7: bool; // anonymous local
    let @8: i32; // anonymous local

    storage_live(@5)
    storage_live(@6)
    storage_live(@7)
    storage_live(@8)
    storage_live(@2)
    storage_live(@3)
    storage_live(@4)
    @4 := copy ((*(self@1)).x)
    @3 := move (@4) > const (0 : i32)
    if move (@3) {
        storage_dead(@4)
        storage_live(@5)
        storage_live(@6)
        @6 := copy ((*(self@1)).y)
        @5 := move (@6) < const (100 : u64)
        if move (@5) {
            storage_dead(@6)
            storage_live(@7)
            storage_live(@8)
            @8 := copy ((*(self@1)).z)
            @7 := move (@8) != const (0 : i32)
            if move (@7) {
                storage_dead(@8)
                storage_dead(@7)
                storage_dead(@5)
                storage_dead(@3)
                storage_dead(@2)
                @0 := ()
                @0 := ()
                return
            }
            else {
                storage_dead(@8)
            }
        }
        else {
            storage_dead(@6)
        }
    }
    else {
        storage_dead(@4)
    }
    panic(core::panicking::panic)
}

// Full name: test_crate::{impl SomeTrait for Point<i32>[Sized<i32>]}
impl SomeTrait for Point<i32>[Sized<i32>] {
    fn some_method<'_0> = {impl SomeTrait for Point<i32>[Sized<i32>]}::some_method<'_0_0>
}

// Full name: test_crate::main
fn main()
{
    let @0: (); // return
    let p@1: test_crate::Point::<i32>; // local
    let @2: (); // anonymous local
    let @3: &'_ (test_crate::Point::<i32>); // anonymous local

    storage_live(p@1)
    p@1 := test_crate::Point::<i32> { x: const (10 : i32), y: const (50 : u64), z: const (1 : i32) }
    storage_live(@2)
    storage_live(@3)
    @3 := &p@1
    @2 := {impl SomeTrait for Point<i32>[Sized<i32>]}::some_method<'_>(move (@3))
    storage_dead(@3)
    storage_dead(@2)
    @0 := ()
    storage_dead(p@1)
    @0 := ()
    return
}

fn test_crate::SomeTrait::some_method<'_0, Self>(@1: &'_0 (Self))
where
    [@TraitClause0]: SomeTrait<Self>,



